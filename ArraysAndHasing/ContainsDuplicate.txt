This problem centres around the use of a hash set. This is a data structure we can use in Python that has many properties that are useful to us. It cannot have duplicates, but we can add and remove from it. It is often used for fast membership checks, and also permits set operations like intersection, union, difference etc. It cannot be indexed and isn't ordered, but is very useful for many types of comparision and membership checks
For this problem, we could initially use a set to keep track of the seen numbers, and check iteratively if each number in the List is in our seen set. However, because we know that the set will remove any duplicates, we can simply this to a one liner of comparing the length of the set to the length of the List. Intuitively, if we know that the lengths are different there must have been at least one duplicate. 
The time and space complexity of both approaches is O(n), as we only make one pass each time and the set can grow to at most n size, when there are no duplicates.
nums.distinct.length comes to mind from Scala, not sure how this is implemented thus I cannot comment on it's efficiency
