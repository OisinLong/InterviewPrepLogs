I'm initially thinking of some kind of caesar shift, if i hardcode a shift then use modulus to fix the range, I should be good. I am going to double check the ord() value range to ensure it starts at 0, if not my modulous might not work. Time complexity would be O(m * n) as we have to iterate over every chr in every word. Space complexity is O(1) as we do not create any extra structures.
After my first attempt and looking at the hints, I found that we didn't really need to encode the strings securely as such. My mind was thinking back to the information security module where we learned much more complex encryption algorithms; I believe that RC4 or Feistel would be overkill here. Granted, a simple feistel may actually be useful here as we can use the same function and just swap the arguments - food for thought perhaps. I digress, I simply use a non ASCII chr as a delimiter and that is it. Ialtered my solution to use .join as it is more efficient than += for arrays. While this solution works, it is not the most efficient so I wil have to complete the video and then attempt it again.
After watching the description part of the video, I can understand the solution given. While comparing my solution to the suggested one, Claude was very hung up on .join vs += for string concatenation. Interviewers care more about algorithmic correctness than implementation details under the hood, so both are sufficient, however mentioning the nuance shows a deeper understanding of Python and would lend well in an interview for sure.
Interviewer: "What's the time complexity?"
You: "O(m) where m is the sum of all string lengths. Though I should note 
that in Python, using += for string concatenation is actually O(mÂ²) due 
to string immutability, so I'd use .join() in practice for O(m) performance."
While my solution is as efficient as the one given, it is not as robust and relys on the contrarian approach of semantics within the question constraints.
After coding the suggested solution, it it pretty easy to understand. We use two pointers and move the window to span the length chrs, then skip the # and count the next length chrs to append to the list, then just repeat this process for the enitre string. There is good use of string segmentation notation so it is nice to be very comfortable with it for implementing this solution, the algorithm is not so hard to understand.
