Without looking at any hints or uing any help, my initia solution was to use ahelper function that calculates the product of an array, and then abstract the logic of removing one element to segmentation in the argument. Then I simply called the function on output[i] and used segmentation around i for the calls t the helper function. I believe the time complexity is O(n^2) as for each number in nums we iterate over n-1 nums again to calculate the product. space complexity of O(n) since we use the extra array for the output. This might be ignored in interviews, but my segmentation of the arrays would account for O(n) actually!
Post hints, didn't watch the vid - was not too hard. I took out my pen and paper to help me visualise traversing the array, as the indexing became a bit too much for my brian to keep up with for the bounds. Initially I was summing the two arrays, and accidentally including the current index into the ___fix sums, however once i used pen and paper i quickly realised my error. I suppose the contrarian approach would have been to just divide by the current element, but the question did flag that as a follow up question so I didn't bother coding that.
The density of indexing made thi problem a little confusing - I definitely needed to visualise the bounds and traversals with pen and paper to avoid any errors. I found the asymmetric nature of the two arrays quite satisfying, it felt like I was completing a dove tail joint or combining halfs of a deck of cards after shuffling. The time complexity of this solution is O(n), as we just make two passes of the array to calculate our ___fix array then combine for the answer. The space complexity is O(n) too, as we simply create the arrays for ___fix products.
After looking at the solutions, I found that we can store the ___fix products directly in the array, and just make two passes on it - leading to O(1) space instead. This is definitely more elegant, with just a little less clear emphasis on the maths. However, it isn't extremely hard to follow, it just makes the maths a little more confusing as we erase the starting state after the first pass. Upon further inspection, this actually does not modify the original array,it just doesn't count the new output array for the space complexity - resulting in constant space complexity.
