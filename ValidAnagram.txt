My first thought was to use XOR, to see if the end result cancelled out. However this does not work for chrs in Python. The default approach in my head was to sort them and compare, but I feel like an in place method must exist. I had to google sorted() vs .sort(), and found that sorted() returns a list.
The starting solution in the videos revolves around building a hashmap for each str, and then comparing the count for each key, with the chrs being the key and the frequencies being the value. .get(x,y) is shown to prevent key errrors where x might not exist, and returns y instead. This is akin to the getorelse I came across while studying Scala.
A key point mentioned in the video is that the interviewers often assume that the sorting algorithms used do not take up any extra space, when in fact they often do. This nuance would be good to mention in an interview to show a deeper consideration of the problem and the abstraction of implemetation in Python especially
The time complexity of the hashing approach is O(n+m), with the space complexity being O(1) since it is always just 26 chrs possible.
The sorting approach is slightly less efficient, with a time complexity of O(n log n + m log m) and a space complexity of O(1), or O(n+m) if a less efficient sorting algorithm is used.
